# 🚀 秒杀系统高并发测试指南

## 📋 测试环境准备

### 前置条件检查

- ✅ Spring Boot 应用已启动（端口 8080）
- ✅ MySQL 数据库运行正常（端口 3306）
- ✅ Redis 缓存服务正常（端口 6379）
- ✅ RabbitMQ 消息队列正常（端口 5672）

### 验证服务状态

```bash
# 检查Docker容器状态
docker-compose ps

# 检查应用健康状态
curl "http://localhost:8080/api/seckill/health"
```

---

## 🧪 测试步骤详解

### 第 1 步：基础功能验证

#### 1.1 初始化测试数据

```bash
# 为优惠券1设置100个库存
curl -X POST "http://localhost:8080/api/seckill/init?voucherId=1&stock=100"

# 检查初始库存
curl "http://localhost:8080/api/seckill/stock/1"
```

**预期结果：**

```json
{
  "voucherId": 1,
  "currentStock": 100,
  "timestamp": 1693564800000
}
```

#### 1.2 单次秒杀测试

```bash
# 用户1001进行第一次秒杀
curl -X POST "http://localhost:8080/api/seckill" \
  -H "Content-Type: application/json" \
  -d '{"userId":1001,"voucherId":1,"limit":1}'
```

**预期结果：**

```json
{
  "code": 0,
  "message": "秒杀成功，正在为您生成订单...",
  "orderId": 1693564801001001,
  "timestamp": 1693564801000
}
```

#### 1.3 验证库存变化

```bash
# 检查库存是否减少1
curl "http://localhost:8080/api/seckill/stock/1"

# 检查用户购买记录
curl "http://localhost:8080/api/seckill/bought?voucherId=1&userId=1001"
```

#### 1.4 限购逻辑测试

```bash
# 同一用户再次尝试购买（应该被拒绝）
curl -X POST "http://localhost:8080/api/seckill" \
  -H "Content-Type: application/json" \
  -d '{"userId":1001,"voucherId":1,"limit":1}'
```

**预期结果：**

```json
{
  "code": 2,
  "message": "超过个人限购数量",
  "orderId": null,
  "timestamp": 1693564802000
}
```

---

### 第 2 步：小规模并发测试（预热）

```bash
# 重新初始化库存
curl -X POST "http://localhost:8080/api/seckill/init?voucherId=1&stock=50"

# 执行10个并发用户测试
python scripts/concurrent-test.py --users 10 --voucher-id 1 --limit 1
```

**预期结果分析：**

- 成功购买：10 个用户
- 库存不足：0 个用户
- 超过限购：0 个用户
- 数据一致性：✅ 通过

---

### 第 3 步：中等规模并发测试

```bash
# 初始化更大库存
curl -X POST "http://localhost:8080/api/seckill/init?voucherId=2&stock=100"

# 执行100个并发用户测试
python scripts/concurrent-test.py --users 100 --voucher-id 2 --limit 1
```

**关键验证点：**

- 成功购买数量 = 库存数量
- 响应时间 < 200ms
- 无 HTTP 错误
- 数据一致性检查通过

---

### 第 4 步：高并发压力测试

#### 4.1 1000 用户抢 100 库存

```bash
# 初始化库存
curl -X POST "http://localhost:8080/api/seckill/init?voucherId=3&stock=100"

# 执行1000并发测试
python scripts/concurrent-test.py --users 1000 --voucher-id 3 --limit 1 --max-workers 50
```

#### 4.2 2000 用户抢 200 库存（极限测试）

```bash
# 初始化更大库存
curl -X POST "http://localhost:8080/api/seckill/init?voucherId=4&stock=200"

# 执行超高并发测试
python scripts/concurrent-test.py --users 2000 --voucher-id 4 --limit 1 --max-workers 100
```

**性能目标：**

- QPS > 1000
- 平均响应时间 < 100ms
- 成功率 = 库存/总请求数
- 系统稳定，无崩溃

---

### 第 5 步：数据一致性验证

#### 5.1 Redis vs 数据库一致性检查

```bash
# 检查Redis中的库存
curl "http://localhost:8080/api/seckill/stock/4"

# 检查数据库中的库存
docker exec seckill-mysql mysql -u root -p123456 -D seckill_test -e "SELECT id, name, stock FROM coupons WHERE id = 4;"

# 检查订单总数
docker exec seckill-mysql mysql -u root -p123456 -D seckill_test -e "SELECT COUNT(*) as total_orders FROM orders WHERE voucher_id = 4;"
```

#### 5.2 一致性验证公式

```
初始库存 = Redis当前库存 + 数据库订单数量
```

---

## 📊 监控和分析

### 实时监控面板

1. **应用状态监控**

   ```bash
   curl "http://localhost:8080/api/seckill/health"
   ```

2. **RabbitMQ 管理界面**

   - 访问：http://localhost:15672
   - 账号：guest / guest
   - 关注：队列消息数、消费速率

3. **Redis 管理界面**
   - 访问：http://localhost:8081
   - 关注：内存使用、命令执行数

### 关键性能指标

| 指标       | 目标值        | 说明           |
| ---------- | ------------- | -------------- |
| QPS        | > 1000        | 每秒处理请求数 |
| 响应时间   | < 100ms       | 平均响应时间   |
| 成功率     | = 库存/请求数 | 精确库存控制   |
| 错误率     | < 0.1%        | HTTP 错误比例  |
| CPU 使用率 | < 80%         | 系统负载       |
| 内存使用率 | < 85%         | 内存管理       |

---

## 🎯 预期测试结果

### 1000 用户抢 100 库存的理想结果

```
📊 测试结果统计
============================================================
📝 总请求数：1000
✅ 秒杀成功：100 (10.00%)
📦 库存不足：900 (90.00%)
🚫 超过限购：0 (0.00%)
❌ HTTP错误：0 (0.00%)
⏰ 请求超时：0 (0.00%)

⏱️ 响应时间统计（毫秒）：
  平均响应时间：45.23
  最小响应时间：12.45
  最大响应时间：156.78
  中位数响应时间：38.90

🚀 平均QPS：1250.00

✅ 数据一致性检查通过
```

---

## ⚡ 核心测试验证点

### 1. 原子性验证

- **测试点**：多个并发请求同时扣减库存
- **验证**：最终库存 = 初始库存 - 成功订单数
- **技术**：Redis Lua 脚本保证原子性

### 2. 一致性验证

- **测试点**：Redis 缓存 vs 数据库数据
- **验证**：异步消息处理后数据最终一致
- **技术**：RabbitMQ 可靠消息投递

### 3. 可用性验证

- **测试点**：高并发下系统稳定性
- **验证**：无系统崩溃，正常响应
- **技术**：连接池、限流、监控

### 4. 性能验证

- **测试点**：高并发处理能力
- **验证**：QPS、响应时间达标
- **技术**：缓存预处理、异步解耦

### 5. 幂等性验证

- **测试点**：消息重复消费处理
- **验证**：重复消息不影响数据准确性
- **技术**：唯一索引、消息 ID 去重

---

## 🚨 常见问题排查

### 问题 1：连接超时

**现象**：大量连接超时错误
**排查**：

```bash
# 检查连接池配置
curl "http://localhost:8080/actuator/metrics/hikaricp.connections.active"

# 检查数据库连接数
docker exec seckill-mysql mysql -u root -p123456 -e "SHOW PROCESSLIST;"
```

### 问题 2：消息积压

**现象**：RabbitMQ 队列消息堆积
**排查**：

- 访问 http://localhost:15672
- 检查消费者状态
- 查看错误日志

### 问题 3：数据不一致

**现象**：Redis 库存与数据库订单数不匹配
**排查**：

```bash
# 检查回滚日志
curl "http://localhost:8080/api/seckill/rollback-logs"

# 检查死信队列
# 在RabbitMQ管理界面查看seckill.order.dlx.queue
```

---

## 📝 测试报告模板

### 测试环境

- 应用版本：1.0.0
- 测试时间：YYYY-MM-DD HH:mm:ss
- 测试场景：N 用户抢购 M 个库存

### 测试结果

- 总请求数：
- 成功数：
- 失败数：
- 平均响应时间：
- QPS：
- 数据一致性：

### 结论

- 系统稳定性：✅/❌
- 性能达标：✅/❌
- 数据准确性：✅/❌
- 建议改进：

---

## 🎉 测试完成确认

完成以下所有测试后，你的高并发秒杀系统验证完毕：

- [ ] 基础功能测试 ✅
- [ ] 小规模并发测试 ✅
- [ ] 中等规模并发测试 ✅
- [ ] 高并发压力测试 ✅
- [ ] 数据一致性验证 ✅
- [ ] 性能指标达标 ✅
- [ ] 异常场景处理 ✅

**测试成功标志：**

1. 所有测试场景通过
2. 数据一致性 100%准确
3. 系统在高并发下稳定运行
4. 性能指标达到预期目标

现在可以开始按照这个指南进行测试了！🚀
